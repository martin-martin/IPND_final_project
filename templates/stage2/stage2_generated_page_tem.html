{% extends "base_tem.html" %}

{% block title %}Elements in Python{% endblock title %}
{% block style %}../../css/style_s2_a.css{% endblock style %}
{% block content %}
	<header>
		<h1>
			Elements in Python
		</h1>
	</header>
	<section>
    	<header>
    	    <h2>
        		 Variables
   			</h2>
        </header>
    	<div>
    		<header>
    			<h3>
    				What are Variables?
    			</h3>
    		</header>
    		<div>
        		<p>
            		Variables in Python are what we are basically working with. They are references to any python element. RUBRIC: Assignment Statement CONTENT: An assignment statement connects a variable to a specific value. &lt;variable&gt; = &lt;value&gt; It behaves like structural language according to the Backus-Naur form. This means the right side of the statement always gets evaluated first! Something like minutes = minutes + 1 is not possible and produces an error. In Python the = sign is used for an assignment, but imagine it to be an arrow <=.
        		</p>
        	</div>
    	</div>
	</section>
	<section>
    	<header>
    	    <h2>
        		 Numbers and Booleans
   			</h2>
        </header>
    	<div>
    		<header>
    			<h3>
    				Numbers: Arithmetics
    			</h3>
    		</header>
    		<div>
        		<p>
            		this is a number: 2 and this another one: 12 we can do arithmetics with them! all these mathematical symbols work as expected: + &nbsp; - &nbsp; * &nbsp; / like this: 2 + 12 and as a result we get: 14 yay! RUBRIC: Numbers: Floating Points CONTENT: python makes bold simplifications if you allow it to! In order to make decimals be considered in the output, one number in the calculation has to be float (=floating point). we do this: 2.0 + 12 and get this: 14.0 other examples make the use of this more obvious. think of pi! RUBRIC: Boolean Operators CONTENT: can have one of two possible states: True or False. <a href=\'94http://en.wikipedia.org/wiki/Boolean_algebra#Operations\'94>Learn more here</a> &lt;value&gt; and &lt;value&gt; True if both values are true, in any other case it evaluates to False. &lt;value&gt; or &lt;value&gt; False only if both values are false, otherwise it evaluates to True. ATTENTION: due to this property, python checks the first variable first. If it evaluates to True, it doesn't check the second one! Therefore the statement could become True, even if the second variable would produce an error! Only if the first variable is False python checks also the second one.
        		</p>
        	</div>
    	</div>
	</section>
	<section>
    	<header>
    	    <h2>
        		 Structured Data: Strings
   			</h2>
        </header>
    	<div>
    		<header>
    			<h3>
    				Strings
    			</h3>
    		</header>
    		<div>
        		<p>
            		&nbsp; 'string' &nbsp; "string" &nbsp; ' ' 'string' ' ' &nbsp; """string""" &nbsp; Use accordingly! e.g. in English there are many ' inside words, they'd close a '' string, so better use "". And in HTML there's many " " e.g. around class names. Can't make a proper string when the symbol interferes, so better take the other one. And these ones ' ' ' make it possible to create multi-line strings. important for e.g. HTML formatting (or other things)! <a href=\'94http://www.codeskulptor.org/#user40_oLgJt0okPb_0.py\'94> &nbsp; : ) &nbsp;</a> RUBRIC: Strings and Lists CONTENT: are examples of structured data. While Strings can only hold a sequence of characters, lists can hold a sequence of anything. Can be accessed through their index: a_string[index_num] and a_list[index_num] The index of a structured element starts with 0 and counts upwards from left to right and downwards from right to left (the last element is therefore -1). Here's a list with its index numbers as elements: index_list = [0, 1, 2 , 3] Watch out not to confuse elements with index numbers! We can also access certain parts, through slicing. string[0:2] returns the first two letters of the string. [start:stop] means "start - up to but not including -end". Note that characters are the elements in strings. then there's things like this [:], [3:], [2:], [4:-1] etc., but I know what this does. When slicing from or into a non-existing index point, it does not produce an error. If, however, you try to index a non-existing index point, it does. Just a little tryout here.
        		</p>
        	</div>
    	</div>
	</section>
	<section>
    	<header>
    	    <h2>
        		 Structured Data: Lists
   			</h2>
        </header>
    	<div>
    		<header>
    			<h3>
    				General
    			</h3>
    		</header>
    		<div>
        		<p>
            		Lists are a very important element in the python programming language. There\'92s lots of stuff one can do with lists! They get made (and displayed) with [ ]. Lists can also be nestedly created and accessed! list[0][1] etc. RUBRIC: Mutation CONTENT: list's can get mutated (strings not). Mutating a list does not modify the original value, it instead creates a new value that the list position gets assigned to. we simply don't have a way to refer to the original value anymore. Doing an assignment statement on a certain position of the list brings in a new value and assigns it to that position, dropping the old assignment. <img src=\'94\'94 title=\'94little boxes\'94 alt=\'94***display a list as a sequence of boxes!***\'94> Some important things about lists!! RUBRIC: Aliasing CONTENT: what assignment statements basically do, is to refer to a certain variable. This means that p = [] refers to a list object. now with lists you can do this: q = p which makes another "link" to that same list. Therefore doing any changes through mutating q, will also be reflected in p (since they refer to the same list!). James Bond and 007 both always refer to the same object, even when something (or everything!) about the object changes. can even be a different person! :) RUBRIC: return or no return CONTENT: When mutating a list that is outside of a function (and gets passed in as an input), there is no need for a return statement, because through aliasing the passed in list is an alias to the original referral to the same list. mutations that happen to the alias list referral inside the function \'a0to the changes in the actual list, which is also referred to by the original referral outside. but since it is the object that gets changed, it is automatically also reflected when we later call the original referral. bam! {\field{\*\fldinst{HYPERLINK "https://www.udacity.com/course/viewer/#!/c-nd000/l-4152219158/e-48746083/m-48695590"}}{\fldrslt \cf2 \ul \ulc2 <a href=\'94https://www.udacity.com/course/viewer/#!/c-nd000/l-4152219158/e-48746083/m-48695590\'94>watch 2.6 "Replace Spy"</a>}} We need the return statements in functions when we are dealing with non-mutable objects. because then the passed-in value gets \'a0assigned to a new value if it is changed within the function, but this then does not have anything to do anymore with what the original value refers to. In lists this is different because they are mutable (therefore, if the function is just about mutating the list, there is no need for a return statement!)\f1\fs24
        		</p>
        	</div>
    	</div>
	</section>
{% endblock content %}